export const dynamic = 'force-dynamic';
import { NextResponse } from 'next/server';
import { supabase } from '@/lib/supabaseServer';

// =======================
//    Helpers de fecha
// =======================
function todayLocal(): string {
  return new Date().toLocaleDateString('en-CA'); // YYYY-MM-DD local
}
function toLocalYYYYMMDD(d?: string | null): string | null {
  if (!d) return null;
  const dt = new Date(d);
  if (isNaN(dt.getTime())) return null;
  return dt.toLocaleDateString('en-CA');
}
function isPaid(installment: {
  principal_amount?: number | null;
  interest_amount?: number | null;
  paid_amount?: number | null;
  late_fee?: number | null;
}) {
  const total =
    Number(installment.principal_amount ?? 0) +
    Number(installment.interest_amount ?? 0) +
    Number(installment.late_fee ?? 0);
  const paid = Number(installment.paid_amount ?? 0);
  return paid >= total - 1e-6;
}
function isOverdue(installment: { due_date?: string | null; status?: string | null }) {
  if (!installment?.due_date) return false;
  const due = new Date(installment.due_date);
  if (isNaN(due.getTime())) return false;
  const today = new Date(todayLocal());
  return due < today && installment.status !== 'Pagado';
}

// Recalcula mora, vencidos y saldo pendiente a partir de cuotas
async function computeLoanAggregates(loanId: string) {
  const { data: inst, error } = await supabase
    .from('loan_installments')
    .select('*')
    .eq('loan_id', loanId);

  if (error) throw error;

  let sumLateFees = 0;
  let overdueAmount = 0;
  let totalPending = 0;

  for (const i of inst ?? []) {
    const principal = Number(i.principal_amount ?? 0);
    const interest = Number(i.interest_amount ?? 0);
    const fee = Number(i.late_fee ?? 0);
    const paid = Number(i.paid_amount ?? 0);
    const cuotaTotal = principal + interest + fee;
    const pendiente = Math.max(cuotaTotal - paid, 0);

    sumLateFees += fee;
    totalPending += pendiente;

    const paidFlag = isPaid(i);
    const overdueFlag = isOverdue(i);
    if (!paidFlag && overdueFlag) overdueAmount += pendiente;
  }

  return { sumLateFees, overdueAmount, totalPending };
}

// Aplica mora a cuotas vencidas sin pago (4% de capital+interés)
async function applyLateFeesForOverdue(loanId: string) {
  const { data: inst, error } = await supabase
    .from('loan_installments')
    .select('id, due_date, status, paid_amount, principal_amount, interest_amount, late_fee')
    .eq('loan_id', loanId);

  if (error) throw error;

  for (const i of inst ?? []) {
    const due = i.due_date ? new Date(i.due_date) : null;
    const isOver = !!due && !isNaN(due.getTime()) && due < new Date(todayLocal());
    const alreadyPaid = Number(i.paid_amount ?? 0) > 0;
    const alreadyLate = (i.status ?? '') === 'Atrasado';

    if (isOver && !alreadyPaid) {
      const base = Number(i.principal_amount ?? 0) + Number(i.interest_amount ?? 0);
      const currentLate = Number(i.late_fee ?? 0);
      const computedLate = base * 0.04; // regla usada en el cliente
      const newLate = currentLate > 0 ? currentLate : computedLate;

      await supabase
        .from('loan_installments')
        .update({
          late_fee: newLate,
          status: alreadyLate ? i.status : 'Atrasado',
        })
        .eq('id', i.id);
    }
  }
}

// Mapear estados de Préstamo EN -> ES
function mapLoanStatus(status?: string | null): string {
  const s = (status || '').toLowerCase();
  switch (s) {
    case 'pending':
      return 'Pendiente';
    case 'approved':
      return 'Aprobado';
    case 'paid':
      return 'Pagado';
    case 'canceled':
    case 'cancelled':
      return 'Cancelado';
    default:
      return status ?? 'Pendiente';
  }
}

// =======================
//    Tipos (minimos locales)
// =======================
type InstallmentInput = {
  id?: string | number;
  due_date?: string;
  dueDate?: string;
  principal_amount?: number;
  interest_amount?: number;
  paid_amount?: number;
  late_fee?: number;
  status?: 'Pendiente' | 'Pagado' | 'Atrasado' | 'Parcial';
  payment_date?: string | null;
};
type LoanInput = {
  id?: string;
  client_id?: string;
  principal: number;
  loan_number?: string;
  interest_rate: number;
  start_date?: string;
  status?: string;
  installments?: InstallmentInput[];
};

// =======================
// GET: listar Préstamos completos (con cliente, cuotas y pagos)
// =======================
export async function GET() {
  try {
    const { data: rawLoans, error: loanError } = await supabase
      .from('loans')
      .select(`
        id,
        client_id,
        loan_number,
        principal,
        interest_rate,
        amount,
        amount_to_pay,
        amount_applied,
        total_pending,
        total,
        balance,
        late_fee,
        overdue_amount,
        loan_date,
        start_date,
        due_date,
        created_at,
        updated_at,
        status,
        loan_installments (
          id,
          loan_id,
          installment_number,
          due_date,
          principal_amount,
          interest_amount,
          paid_amount,
          late_fee,
          status,
          payment_date
        ),
        loan_payments (
          id,
          loan_id,
          installment_id,
          amount_paid,
          payment_method,
          principal_applied,
          change_returned,
          created_at
        ),
        clients (
          id,
          name,
          email
        )
      `)
      .order('created_at', { ascending: false })
      .order('installment_number', { foreignTable: 'loan_installments', ascending: true });

    if (loanError) throw loanError;

    const loans = (rawLoans ?? []).map((loan: any) => {
      const clientData = Array.isArray(loan.clients)
        ? loan.clients[0] ?? {}
        : loan.clients ?? {};

      return {
        id: loan.id,
        loanNumber: loan.loan_number,
        client_id: loan.client_id,
        client_name: clientData.name ?? '',
        client_email: clientData.email ?? '',
        principal: Number(loan.principal) || 0,
        interestRate: Number(loan.interest_rate) || 0,
        amount: Number(loan.amount) || 0,
        amountToPay: Number(loan.amount_to_pay) || 0,
        amountApplied: Number(loan.amount_applied) || 0,
        totalPending: Number(loan.total_pending) || 0,
        total: Number(loan.total) || 0,
        balance: Number(loan.balance) || 0,
        lateFee: Number(loan.late_fee) || 0,
        overdueAmount: Number(loan.overdue_amount) || 0,
        loanDate: loan.loan_date ? toLocalYYYYMMDD(loan.loan_date) : null,
        startDate: loan.start_date ? toLocalYYYYMMDD(loan.start_date) : null,
        dueDate: loan.due_date ? toLocalYYYYMMDD(loan.due_date) : null,
        createdAt: loan.created_at,
        updatedAt: loan.updated_at,
        status: mapLoanStatus(loan.status),

        installments:
          (loan.loan_installments ?? []).map((i: any) => ({
            id: i.id,
            installmentNumber: i.installment_number,
            principal_amount: Number(i.principal_amount) || 0,
            interest_amount: Number(i.interest_amount) || 0,
            paidAmount: Number(i.paid_amount) || 0,
            lateFee: Number(i.late_fee) || 0,
            dueDate: i.due_date,
            paymentDate: i.payment_date,
            status: i.status,
            // (compat opcional)
            due_date: i.due_date,
          })) ?? [],

        payments:
          (loan.loan_payments ?? []).map((p: any) => ({
            id: p.id,
            installment_id: p.installment_id,
            amount_paid: Number(p.amount_paid) || 0,
            payment_method: p.payment_method ?? 'cash',
            principal_applied: Number(p.principal_applied) || 0,
            change_returned: Number(p.change_returned) || 0,
            created_at: p.created_at,
          })) ?? [],
      };
    });

    const { data: clients, error: clientError } = await supabase
      .from('clients')
      .select('id, name, email');

    if (clientError) throw clientError;

    return NextResponse.json({ loans, clients });
  } catch (error) {
    console.error('  Error en GET /api/loans:', error);
    return NextResponse.json(
      { message: 'Error fetching loans', error: String(error) },
      { status: 500 }
    );
  }
}

// =======================
// POST: carear Préstamo (usa start_date y calcula due_date)
// =======================
export async function POST(request: Request) {
  try {
    const body = (await request.json()) as LoanInput;
    const { installments, ...loanData } = body;

    if (!loanData.client_id) {
      return NextResponse.json(
        { message: 'Debe seleccionar un cliente v lido para carear un Préstamo' },
        { status: 400 }
      );
    }

    const principal = Number(loanData.principal) || 0;
    const interestRate = Number(loanData.interest_rate) || 0;
    const interest = principal * (interestRate / 100);
    const total = principal + interest;

    const start_date = loanData.start_date
      ? toLocalYYYYMMDD(loanData.start_date)
      : todayLocal();

    const due_date =
      installments && installments.length > 0
        ? toLocalYYYYMMDD(
            (installments[installments.length - 1] as any).dueDate ??
              (installments[installments.length - 1] as any).due_date
          )
        : start_date;

    const { data: loan, error: loanError } = await supabase
      .from('loans')
      .insert({
        client_id: loanData.client_id,
        loan_number: loanData.loan_number || `LN-${Date.now()}`,
        principal,
        interest_rate: interestRate,
        amount: principal,
        amount_to_pay: total,
        total,
        balance: total,
        total_pending: total,
        loan_date: todayLocal(),
        start_date,
        due_date,
        late_fee: 0,
        overdue_amount: 0,
        status: loanData.status || 'Pendiente',
      })
      .select()
      .single();

    if (loanError) throw loanError;

    // Cuotas vinculadas
    let careatedInstallments: any[] = [];
    if (installments && installments.length > 0) {
      const fallback = todayLocal();

      const installmentsWithLoan = installments.map((i: any, idx: number) => ({
        loan_id: loan.id,
        installment_number:
          i.installmentNumber ?? i.installment_number ?? idx + 1,
        due_date: toLocalYYYYMMDD(i.dueDate ?? i.due_date ?? fallback),
        principal_amount: i.principal_amount ?? 0,
        interest_amount: i.interest_amount ?? 0,
        paid_amount: 0,
        late_fee: 0,
        status: i.status || 'Pendiente',
      }));

      const { data: instData, error: instError } = await supabase
        .from('loan_installments')
        .insert(installmentsWithLoan)
        .select();

      if (instError) throw instError;

      careatedInstallments = (instData ?? []).map((i: any) => ({
        id: i.id,
        installmentNumber: i.installment_number,
        principal_amount: Number(i.principal_amount) || 0,
        interest_amount: Number(i.interest_amount) || 0,
        paidAmount: Number(i.paid_amount) || 0,
        lateFee: Number(i.late_fee) || 0,
        dueDate: toLocalYYYYMMDD(i.due_date),
        paymentDate: i.payment_date ? toLocalYYYYMMDD(i.payment_date) : null,
        status: i.status,
        // (compat)
        due_date: toLocalYYYYMMDD(i.due_date),
      }));
    }

    // Recalcular mora, vencidos y saldo pendiente desde cuotas recién insertadas
    const { sumLateFees, overdueAmount, totalPending } = await computeLoanAggregates(loan.id);

    await supabase
      .from('loans')
      .update({
        late_fee: sumLateFees,
        overdue_amount: overdueAmount,
        total_pending: totalPending,
        balance: totalPending,
        updated_at: new Date().toISOString(),
      })
      .eq('id', loan.id);

    // Ajuste automático del capital si el total prestado supera el capital registrado
    try {
      const { data: allLoans } = await supabase.from('loans').select('amount');
      const lentSum = (allLoans ?? []).reduce((acc: number, r: any) => acc + Number(r.amount || 0), 0);
      const { data: cap } = await supabase
        .from('capital')
        .select('id, total')
        .eq('id', 1)
        .maybeSingle();
      const currentTotal = Number(cap?.total ?? 0);
      if (lentSum > currentTotal) {
        await supabase.from('capital').upsert({ id: 1, total: lentSum });
      }
    } catch (e) {
      console.warn('Aviso: no se pudo recalcular capital autom ticamente:', e);
    }

    return NextResponse.json({
      id: loan.id,
      loanNumber: loan.loan_number,
      client_id: loan.client_id,
      principal: Number(loan.principal) || 0,
      interestRate: Number(loan.interest_rate) || 0,
      total: Number(loan.total) || 0,
      balance: totalPending,
      totalPending,
      amountToPay: Number(loan.amount_to_pay) || 0,
      lateFee: sumLateFees,
      overdueAmount,
      loanDate: toLocalYYYYMMDD(loan.loan_date),
      startDate: toLocalYYYYMMDD(loan.start_date),
      dueDate: toLocalYYYYMMDD(loan.due_date),
      status: loan.status,
      amountApplied: Number(loan.amount_applied) || 0,
      clientId: loan.client_id ?? null,
      clientName: '',
      installments: careatedInstallments ?? [],
      payments: [],
    });
  } catch (error) {
    console.error('  Error careando Préstamo:', error);
    return NextResponse.json(
      { message: 'Error careando Préstamo', error: String(error) },
      { status: 500 }
    );
  }
}
// =======================
// PUT: actualizar Préstamo (recalcula totales y due_date)
// =======================
export async function PUT(request: Request) {
  try {
    const body = (await request.json()) as LoanInput;
    const { id, installments, ...loanData } = body;

    if (!id) {
      return NextResponse.json({ message: 'Loan ID is required for update' }, { status: 400 });
    }

    // obtener amount_applied actual para no perderlo
    const { data: current, error: curErr } = await supabase
      .from('loans')
      .select('amount_applied')
      .eq('id', id)
      .single();
    if (curErr) throw curErr;

    const principal = Number(loanData.principal) || 0;
    const interestRate = Number(loanData.interest_rate) || 0;
    const interest = principal * (interestRate / 100);
    const total = principal + interest;

    const start_date = loanData.start_date
      ? toLocalYYYYMMDD(loanData.start_date)
      : todayLocal();

    const lastDue =
      installments && installments.length > 0
        ? toLocalYYYYMMDD(
            (installments[installments.length - 1] as any).dueDate ??
              (installments[installments.length - 1] as any).due_date
          )
        : null;


    const { error: loanError } = await supabase
      .from('loans')
      .update({
        client_id: loanData.client_id,
        loan_number: loanData.loan_number,
        principal,
        interest_rate: interestRate,
        amount: principal,
        amount_to_pay: total,
        total,
        // balance y total_pending se recalculan tras cuotas
        start_date,
        due_date: lastDue,
        status: loanData.status || 'Pendiente',
        updated_at: new Date().toISOString(),
      })
      .eq('id', id);

    if (loanError) throw loanError;

    if (installments) {
      await supabase.from('loan_installments').delete().eq('loan_id', id);

      const fallback = todayLocal();
      const installmentsWithLoan = installments.map((i, idx) => ({
        loan_id: id,
        installment_number:
          (i as any).installmentNumber ?? (i as any).installment_number ?? idx + 1,
        due_date: toLocalYYYYMMDD((i as any).dueDate ?? (i as any).due_date ?? fallback),
        principal_amount: i.principal_amount ?? 0,
        interest_amount: i.interest_amount ?? 0,
        paid_amount: 0,
        late_fee: 0,
        status: i.status || 'Pendiente',
      }));

      const { error: instError } = await supabase
        .from('loan_installments')
        .insert(installmentsWithLoan);

      if (instError) throw instError;
    }

    // Responder con Préstamo completo (mismo shape que GET)
    // Recalcular mora, vencidos y saldo pendiente desde cuotas
    try {
      const { sumLateFees, overdueAmount, totalPending } = await computeLoanAggregates(id);
      await supabase
        .from('loans')
        .update({
          late_fee: sumLateFees,
          overdue_amount: overdueAmount,
          total_pending: totalPending,
          balance: totalPending,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id);
    } catch {}

    const { data: updated, error: selErr } = await supabase
      .from('loans')
      .select(`
        id,
        client_id,
        loan_number,
        principal,
        interest_rate,
        amount,
        amount_to_pay,
        amount_applied,
        total_pending,
        total,
        balance,
        late_fee,
        overdue_amount,
        loan_date,
        start_date,
        due_date,
        created_at,
        updated_at,
        status,
        loan_installments (
          id,
          loan_id,
          installment_number,
          due_date,
          principal_amount,
          interest_amount,
          paid_amount,
          late_fee,
          status,
          payment_date
        ),
        loan_payments (
          id,
          loan_id,
          installment_id,
          amount_paid,
          payment_method,
          principal_applied,
          change_returned,
          created_at
        ),
        clients (
          id,
          name,
          email
        )
      `)
      .eq('id', id)
      .single();

    if (selErr) throw selErr;

    const clientData = Array.isArray(updated.clients)
      ? updated.clients[0] ?? {}
      : updated.clients ?? {};

    const response = {
      id: updated.id,
      loanNumber: updated.loan_number,
      client_id: updated.client_id,
      client_name: clientData.name ?? '',
      client_email: clientData.email ?? '',
      principal: Number(updated.principal) || 0,
      interestRate: Number(updated.interest_rate) || 0,
      amount: Number(updated.amount) || 0,
      amountToPay: Number(updated.amount_to_pay) || 0,
      amountApplied: Number(updated.amount_applied) || 0,
      totalPending: Number(updated.total_pending) || 0,
      total: Number(updated.total) || 0,
      balance: Number(updated.balance) || 0,
      lateFee: Number(updated.late_fee) || 0,
      overdueAmount: Number(updated.overdue_amount) || 0,
      loanDate: updated.loan_date ? toLocalYYYYMMDD(updated.loan_date) : null,
      startDate: updated.start_date ? toLocalYYYYMMDD(updated.start_date) : null,
      dueDate: updated.due_date ? toLocalYYYYMMDD(updated.due_date) : null,
      createdAt: updated.created_at,
      updatedAt: updated.updated_at,
      status: mapLoanStatus(updated.status),
      installments:
        (updated.loan_installments ?? []).map((i: any) => ({
          id: i.id,
          installmentNumber: i.installment_number,
          principal_amount: Number(i.principal_amount) || 0,
          interest_amount: Number(i.interest_amount) || 0,
          paidAmount: Number(i.paid_amount) || 0,
          lateFee: Number(i.late_fee) || 0,
          dueDate: i.due_date,
          paymentDate: i.payment_date,
          status: i.status,
          due_date: i.due_date,
        })) ?? [],
      payments:
        (updated.loan_payments ?? []).map((p: any) => ({
          id: p.id,
          installment_id: p.installment_id,
          amount_paid: Number(p.amount_paid) || 0,
          payment_method: p.payment_method ?? 'cash',
          principal_applied: Number(p.principal_applied) || 0,
          change_returned: Number(p.change_returned) || 0,
          created_at: p.created_at,
        })) ?? [],
    };

    return NextResponse.json(response);
  } catch (error) {
    console.error('  Error actualizando Préstamo:', error);
    return NextResponse.json({ message: 'Error updating loan', error: String(error) }, { status: 500 });
  }
}

// =======================
// DELETE
// =======================
export async function DELETE(request: Request) {
  try {
    const { id } = (await request.json()) as { id: string };

    if (!id) {
      return NextResponse.json({ message: 'Loan ID is required for delete' }, { status: 400 });
    }

    await supabase.from('loan_installments').delete().eq('loan_id', id);
    await supabase.from('loan_payments').delete().eq('loan_id', id);

    const { error } = await supabase.from('loans').delete().eq('id', id);
    if (error) throw error;

    return NextResponse.json({ message: 'Loan deleted successfully' });
  } catch (error) {
    console.error('  Error deleting loan:', error);
    return NextResponse.json({ message: 'Error deleting loan', error: String(error) }, { status: 500 });
  }
}

// =======================
// PATCH: procesar pago
// =======================
export async function PATCH(request: Request) {
  try {
    const body = await request.json();
    const { loanId, installmentId, amountPaid, paymentMethod } = body;

    if (!loanId || !amountPaid) {
      return NextResponse.json({ error: 'Faltan datos para procesar el pago' }, { status: 400 });
    }

    // 1   Obtener Préstamo con cuotas
    const { data: loan, error: loanError } = await supabase
      .from('loans')
      .select('*, loan_installments(*)')
      .eq('id', loanId)
      .single();

    if (loanError || !loan) throw loanError || new Error('Préstamo no encontrado');

    let remainingPayment = Number(amountPaid);
    const installments = [...(loan.loan_installments || [])].sort(
      (a, b) => a.installment_number - b.installment_number
    );

    let totalApplied = 0;
    let totalChange = 0;

    // 2   Aplicar pago a cuotas en orden
    for (const inst of installments) {
      if (remainingPayment <= 0) break;

      const cuotaTotal =
        Number(inst.principal_amount) +
        Number(inst.interest_amount) +
        Number(inst.late_fee ?? 0);
      const yaPagado = Number(inst.paid_amount ?? 0);
      const pendiente = Math.max(cuotaTotal - yaPagado, 0);

      if (pendiente <= 0) continue;

      if (remainingPayment >= pendiente) {
        // Paga completamente
        const { error: updateError } = await supabase
          .from('loan_installments')
          .update({
            paid_amount: cuotaTotal,
            status: 'Pagado',
            payment_date: todayLocal(),
          })
          .eq('id', inst.id);

        if (updateError) throw updateError;

        totalApplied += pendiente;
        remainingPayment -= pendiente;
      } else {
        // Pago parcial
        const nuevoAbono = yaPagado + remainingPayment;

        const { error: partialError } = await supabase
          .from('loan_installments')
          .update({
            paid_amount: nuevoAbono,
            status: 'Parcial',
            payment_date: todayLocal(),
          })
          .eq('id', inst.id);

        if (partialError) throw partialError;

        totalApplied += remainingPayment;
        remainingPayment = 0;
      }
    }

    // 3   Cambio (si sobra)
    if (remainingPayment > 0) {
      totalChange = remainingPayment;
      remainingPayment = 0;
    }

    // 4   Recalcular mora, vencidos y saldo pendiente
    const { sumLateFees, overdueAmount, totalPending } = await computeLoanAggregates(loanId);

    // 5   Actualizar Préstamo principal
    const totalPagado = Number(loan.amount_applied ?? 0) + totalApplied;
    const totalPendiente = totalPending;
    const statusFinal = totalPendiente <= 0 ? 'Pagado' : loan.status;

    const { error: loanUpdateError } = await supabase
      .from('loans')
      .update({
        amount_applied: totalPagado,
        total_pending: totalPendiente,
        balance: totalPendiente,
        late_fee: sumLateFees,
        overdue_amount: overdueAmount,
        status: statusFinal,
        updated_at: new Date().toISOString(),
      })
      .eq('id', loanId);

    if (loanUpdateError) throw loanUpdateError;

    // 6   Registrar pago
    const { error: payError } = await supabase.from('loan_payments').insert({
      loan_id: loanId,
      installment_id: installmentId ?? null,
      amount_paid: amountPaid,
      payment_method: paymentMethod || 'cash',
      principal_applied: totalApplied,
      change_returned: totalChange,
      created_at: new Date().toISOString(),
    });
    if (payError) throw payError;

    // 7   Devolver Préstamo actualizado (misma forma que GET, pero 1  tem)
    const { data: updated, error: selErr } = await supabase
      .from('loans')
      .select(`
        id,
        client_id,
        loan_number,
        principal,
        interest_rate,
        amount,
        amount_to_pay,
        amount_applied,
        total_pending,
        total,
        balance,
        late_fee,
        overdue_amount,
        loan_date,
        start_date,
        due_date,
        created_at,
        updated_at,
        status,
        loan_installments (
          id,
          loan_id,
          installment_number,
          due_date,
          principal_amount,
          interest_amount,
          paid_amount,
          late_fee,
          status,
          payment_date
        ),
        loan_payments (
          id,
          loan_id,
          installment_id,
          amount_paid,
          payment_method,
          principal_applied,
          change_returned,
          created_at
        ),
        clients (
          id,
          name,
          email
        )
      `)
      .eq('id', loanId)
      .single();

    if (selErr) throw selErr;

    const clientData = Array.isArray(updated.clients)
      ? updated.clients[0] ?? {}
      : updated.clients ?? {};

    const updatedLoan = {
      id: updated.id,
      loanNumber: updated.loan_number,
      client_id: updated.client_id,
      client_name: clientData.name ?? '',
      client_email: clientData.email ?? '',
      principal: Number(updated.principal) || 0,
      interestRate: Number(updated.interest_rate) || 0,
      amount: Number(updated.amount) || 0,
      amountToPay: Number(updated.amount_to_pay) || 0,
      amountApplied: Number(updated.amount_applied) || 0,
      totalPending: Number(updated.total_pending) || 0,
      total: Number(updated.total) || 0,
      balance: Number(updated.balance) || 0,
      lateFee: Number(updated.late_fee) || 0,
      overdueAmount: Number(updated.overdue_amount) || 0,
      loanDate: updated.loan_date ? toLocalYYYYMMDD(updated.loan_date) : null,
      startDate: updated.start_date ? toLocalYYYYMMDD(updated.start_date) : null,
      dueDate: updated.due_date ? toLocalYYYYMMDD(updated.due_date) : null,
      createdAt: updated.created_at,
      updatedAt: updated.updated_at,
      status: mapLoanStatus(updated.status),
      installments:
        (updated.loan_installments ?? []).map((i: any) => ({
          id: i.id,
          installmentNumber: i.installment_number,
          principal_amount: Number(i.principal_amount) || 0,
          interest_amount: Number(i.interest_amount) || 0,
          paidAmount: Number(i.paid_amount) || 0,
          lateFee: Number(i.late_fee) || 0,
          dueDate: i.due_date,
          paymentDate: i.payment_date,
          status: i.status,
          // compat
          due_date: i.due_date,
        })) ?? [],
      payments:
        (updated.loan_payments ?? []).map((p: any) => ({
          id: p.id,
          installment_id: p.installment_id,
          amount_paid: Number(p.amount_paid) || 0,
          payment_method: p.payment_method ?? 'cash',
          principal_applied: Number(p.principal_applied) || 0,
          change_returned: Number(p.change_returned) || 0,
          created_at: p.created_at,
        })) ?? [],
    };

    // Actualizar capital con el efectivo neto recibido (amountPaid - cambio devuelto)
    let capitalTotal: number | null = null;
    try {
      const netCashIn = Number(amountPaid || 0) - Number(totalChange || 0);
      if (!isNaN(netCashIn) && netCashIn !== 0) {
        const { data: cap } = await supabase
          .from('capital')
          .select('id, total')
          .eq('id', 1)
          .maybeSingle();
        const current = Number(cap?.total ?? 0);
        const newTotal = current + netCashIn;
        await supabase.from('capital').upsert({ id: 1, total: newTotal });
        capitalTotal = newTotal;
      }
    } catch (e) {
      console.warn('Aviso: no se pudo actualizar capital tras pago:', e);
    }

    return NextResponse.json({
      message: 'Pago procesado correctamente',
      totalApplied,
      totalChange,
      updatedLoan,
      // Compatibilidad con el cliente
      loan: updatedLoan,
      installment: (updatedLoan.installments as any[]).find((x) => x.id === installmentId),
      totalPending: updatedLoan.totalPending,
      change: totalChange,
      principalApplied: totalApplied,
      capitalTotal,
    });
  } catch (error) {
    console.error('  Error procesando pago:', error);
    return NextResponse.json(
      { error: 'Error procesando pago', details: String(error) },
      { status: 500 }
    );
  }
}


